<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Index</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Index</h1>

    


    


    <h3> </h3>









    




    <section>
        <article><h1>lib.rtcomm.clientjs</h1><p>The rtcomm.js library is a JavaScript Universal Module Description(UMD) formatted module that provides an API for client side web application developers to enable WebRTC functionality.  This module handles signaling and creation of WebRTC PeerConnections between endpoints in a simple and flexible way. This library is works with the 'rtcomm-1.0' feature in WebSphere Liberty Profile server.</p>
<h2>Requirements</h2><ol>
<li>An MQTT Server such as IBM MessageSite. For prototyping and development, it is possible to use <code>broker.mqttdashboard.com</code>.</li>
<li>Chrome or Firefox web browsers that support WebRTC.</li>
<li>A Liberty Profile server that runs with the  <code>rtcomm-1.0</code> feature enabled. </li>
</ol>
<h2>Download</h2><p> Download the latest 'rtcomm.zip' from this <a href="https://github.com/WASdev/lib.rtcomm.clientjs/releases/download/v1.0.0-beta.1/rtcomm.zip">link</a>  This file contains the library, sample and documentation.</p>
<h2>Quickstart</h2><h3>Using a WAR file</h3><p>Given the directory structure:</p>
<pre class="prettyprint source"><code>   WebContent/
      /WEB-INF/
      /META-INF/</code></pre><p>Extract rtcomm.zip into the WebContent directory.  It should end up looking like:</p>
<pre class="prettyprint source"><code>WebContent/
  /WEB-INF/
  /META-INF/
  /js/
  /sample/
  /docs
  index.html</code></pre><p>Edit the file 'WebContent/sample/videoClient.html' or 'WebContent/sample/videoClientBS.html'.  Find the creation of the npConfig object:</p>
<pre class="prettyprint source"><code> var npConfig = {
   server: 'broker.mqttdashboard.com',
   port: 8000,
   userid : null,
   serviceTopic : "nodeConnector",
   topicPath: "/rtcomm/",
   register: false,
   createEndpoint: false
 };</code></pre><p>The above are the defaults and need to be changed to match the rtcomm-1.0 feature configuration in the server.xml for the liberty profile server you are using.  This is documented <a href="http://www-01.ibm.com/support/knowledgecenter/was_beta_liberty/com.ibm.websphere.wlp.nd.multiplatform.doc/ae/twlp_config_rtcomm.html">here</a>:</p>
<p>Once the above configuration has been changed, you should be able to DEPLOY your WAR file to the Liberty Server.  You can either place the WAR file in the <strong>dropins</strong> directory for your server or configure it in the server.xml and place it in the <strong>apps</strong> directory.</p>
<p>Access your server url and the 'index.html' page should be displayed with links to the sample Client you have configured and the documentation for the library.</p>
<h2>Library Overview</h2><p>The library exposes a single object called a 'RtcommEndpointProvider'.  The RtcommEndpointProvider utilizes MQTT over WebSockets to communicate with the rtcomm-1.0 feature via the 'nodeConnector'.  The RtcommEndpointProvider object represents an Endpoint in the rtcomm infrastructure. The primary purpose of the RtcommEndpointProvider is to create RtcommEndpoints.  Each RtcommEndpoint object provides the functionality to create a WebRTCConnection between RtcommEndpoint Objects and link these WebRTCConnection objects to UI components via events and media streams.   A WebRTCConnection is a combination of a Signaling Session and a RTCPeerConnection, enabling end-to-end communication between two Endpoints.</p>
<p><p>
<strong>NOTE:</strong>  This library does not include any UI related components.  A simple html file demonstrating the use of the rtcomm.js library is included in the rtcomm.zip file.  It is discussed in the Sample section.</p>
<h2>Install</h2><p>After you have downloaded 'rtcomm.zip', Copy and unzip this file to the application development directory where JavaScript libraries are stored.  </p>
<ol>
<li>Unzip rtcomm.zip file and copy two files into your application($APPDIR):<pre class="prettyprint source"><code> unzip rtcomm.zip
 cp ibm/rtcomm.js $APPDIR
 cp lib/mqtt31ws.js $APPDIR</code></pre></li>
<li>Embed in your application:</li>
</ol>
<p>Include the mqtt library in your application:</p>
<p><code>&lt;script src=&quot;lib/mqttws31.js&quot;&gt;&lt;/script&gt;</code></p>
<p>Then, include the rtcomm library in your application.  This can be done classically via a global or as an AMD Module via RequireJS or dojo:</p>
<p><p>
<strong>Classically, imported to the 'ibm.rtcomm' namespace:</strong></p>
<p><code>&lt;script src=&quot;js/ibm/rtcomm.js&quot;&gt;&lt;/script&gt;</code></p>
<p><strong>Via AMD(assuming proper AMD configuration):</strong></p>
<pre class="prettyprint source"><code>var endpointProvider = null; // We need to be global.
require( ["ibm/rtcomm"],
function(rtcomm) {
  endpointProvider = new rtcomm.RtcommEndpointProvider();
});</code></pre><h2>Using the RtcommEndpointProvider</h2><p>The following shows how to configure and instantiate the RtcommEndpointProvider. You need to know the MQTT Server address and ensure you use a unique 'connectorTopicName':</p>
<pre class="prettyprint source"><code> var endpointProvider = new ibm.rtcomm.RtcommEndpointProvider(); 
 var endpointProviderConfig = {
        server : "iot.eclipse.org", // mqtt server 
        userid : 'ibmAgent1@mysurance.org', // userid
        connectorTopicName : 'nodeConnector', // RTCOMM connector Topic name
        connectorTopicPath: '/rtcomm/MyCompany/', // RTCOMM connector Topic path
        port : 80, // mqtt port
        register: true, // Register w/ Signalling Endpoint
        createEndpoint : true,  // generate RtcommEndpoint instance, pass in onSuccess
        credentials : null // no security for this example (sso token, etc)
      };

 // Initialize the Service. [Using onSuccess/onFailure callbacks]
 // This initializes the MQTT layer and enables inbound Communication.
 var rtcommEndpoint = null;  
 ibmEndpointProvider.init(endpointProviderConfig, 
    /* onSuccess */ function(object) {
         console.log('init was successful, rtcommEndpoint: ', object);
          rtcommEndpoint = object;
    },
   /* onFailure */ function(error) {
         console.error('init failed: ', error);
   }
 );</code></pre><p>The instantiation example above automatically registers with the 'rtcomm server' and creates a RtcommEndpoint which is assigned to the 'rtcommEndpoint' variable. However, the developer can choose to decouple this behavior and specifically register  and createRtcommEndpoint.   The 'rtcommEndpoint' can now be used to create connections(calls) to other Endpoints.</p>
<h4>Using the rtcommEndpoint object</h4><p>The rtcommEndpoint object provides an interface for the UI Developer to attach Video and Audio input/output.  Essentially mapping a broadcast stream(a MediaStream that is intended to be sent) to a RTCPeerConnection output stream.   When an inbound stream is added to a RTCPeerConnection, then this also informs the RTCPeerConnection where to send that stream in the User Interface.  </p>
<p>Once the object has been created, in order to enable audio/video between Endpoints, mediaIn &amp; mediaOut must be attached to DOM Nodes [The inbound <code>&lt;video&gt;</code> and outbound <code>&lt;video&gt;</code> elements for your application]. </p>
<pre class="prettyprint source"><code>// Configure & attach the rtcommEndpoint to UI Video Endpoint
rtcommEndpoint.setMediaOut(OutboundVideoEndpoint);
rtcommEndpoint.setMediaIn(InboundVideoEndpoint);
rtcommEndpoint.audio = true; // Support audio
rtcommEndpoint.video = true; // Support Video</code></pre><p>To create an outbound real-time connection with a specific user, the developer would attach the action of a UI component (like a Button) to the addEndpoint method of the rtcommEndpoint and call it when clicked:</p>
<pre class="prettyprint source"><code>// Setup a real-time connection with specified user.
rtcommEndpoint.addEndpoint('userid');</code></pre><p>To disconnect a real-time connection, the developer should call disconnect().</p>
<pre class="prettyprint source"><code>// Disconnect this endpoint from all other attached users.
rtcommEndpoint.disconnect();</code></pre><p>To handle events, the developer should attach callback functions to the events generated by the on() handler:</p>
<pre class="prettyprint source"><code> // Attach a handler to the 'connected' event
 endpointObject.on('connected', function(event_object){
     console.log(event_object.message);
 });</code></pre><p>The available events are:</p>
<table>
<tr><th>event</th><th> description</th></tr>
<tr><td> connected </td><td>A connection to a peer has been established</td></tr>
<tr><td>disconnected</td><td> The connection to a peer has been closed</td></tr>
<tr><td> refer </td><td>A third party call has been initiated (similar to incoming)</td></tr>
<tr><td>ringing </td><td>A peer has been reached, but not connected (inbound/outound)</td></tr>
<tr><td>trying</td><td> A connection is being attempted (outbound only) </td></tr>
<tr><td> incoming </td><td> An inbound connection is being requested. </td></tr>
<tr><td>message</td><td> A message has arrived from a peer </td></tr>
</table>


<h4>Advanced Features of the RtcommEndpointProvider &amp; RtcommEndpoint Objects</h4><p>The above scenario is the simplest way to connect two endpoints using the rtcomm-1.0 feature infrastructure.  However, these objects support several additional features:</p>
<ol>
<li><p>Each RtcommEndpointProvider is tied specifically to the MQTT Server and Service Topic.  To use multiple MQTT Servers/ServiceTopics, multiple RtcommEndpointProviders can be configured and intialized.</p>
</li>
<li><p>The RtcommEndpointProvider can create many RtcommEndpoints.  Each RtcommEndpoint can have a single WebRTCConnection.</p>
</li>
</ol>
<h2>Sample videoClient</h2><p>'rtcomm.zip' contains a 'sample/videoClient.html' file that demonstrates how to use the rtcomm.js library.   This sample can be placed on a web server with the js/lib/mqttws31.js, js/ibm/rtcomm.js from the rtcomm.zip. This sample is also dependent on jQuery that is accessed with the jQuery CDN (http://code.jquery.com/jquery-2.1.1.js). You can obtain jQuery 2.1.1 from the Downloading jQuery site.</p>
<ol>
<li><p>Extract the Zip file into your Web Server Directory</p>
</li>
<li><p>Change the configuration to match that used in the server.xml for the rtcomm-1.0 feature as described <a href="http://www-01.ibm.com/support/knowledgecenter/was_beta_liberty/com.ibm.websphere.wlp.nd.multiplatform.doc/ae/twlp_config_rtcomm.html">here</a>:</p>
</li>
</ol>
<pre class="prettyprint source"><code>    var npConfig = {
      server: 'broker.mqttdashboard.com',
      port: 8000,
      userid : null,
      connectorTopicName : "nodeConnector",
      connectorTopicPath: "/rtcomm/",
      register: true,
      createEndpoint: true
    };</code></pre><ol>
<li>Access the index.html file via your web browser.  This will provide links to the documentation and Sample Client.</li>
</ol>
<h1>Building the code</h1><p>If you want to clone the repository and build this yourself, you will need:</p>
<ol>
<li>ant v 1.8.4 (Not tested with any other, but may work)</li>
<li>ant-contrib from:  http://sourceforge.net/projects/ant-contrib/files/ant-contrib/1.0b3/ant-contrib-1.0b3-bin.zip/download</li>
</ol>
<p>Then in order to build just run:</p>
<pre class="prettyprint source"><code> ant</code></pre><p> This will create a build directory with the following contents:</p>
<pre class="prettyprint source"><code>   README.md
   index.html
   |-docs
   |---jsDoc
   |-----scripts
   |-------prettify
   |-----styles
   |-js
   |---ibm
   |---lib
   |---umd
   |-----ibm
   |-------rtcomm
   |-lib
   |-sample
   |---resources
   |-----css</code></pre><p>It will also copy the rtcomm.zip and docs into the dist directory.</p></article>
    </section>






</div>

<nav>
    <h2><a href="index.html">Index</a></h2><h3>Modules</h3><ul><li><a href="module-rtcomm.html">rtcomm</a></li></ul><h3>Classes</h3><ul><li><a href="module-rtcomm.EndpointProvider.html">EndpointProvider</a></li><li><a href="module-rtcomm.RtcommEndpoint.html">RtcommEndpoint</a></li><li><a href="module-rtcomm.util.RtcommBaseObject.html">RtcommBaseObject</a></li></ul><h3>Events</h3><ul><li><a href="module-rtcomm.EndpointProvider.html#event:newendpoint">newendpoint</a></li><li><a href="module-rtcomm.RtcommEndpoint.html#event:connected">connected</a></li><li><a href="module-rtcomm.RtcommEndpoint.html#event:disconnected">disconnected</a></li><li><a href="module-rtcomm.RtcommEndpoint.html#event:incoming">incoming</a></li><li><a href="module-rtcomm.RtcommEndpoint.html#event:message">message</a></li><li><a href="module-rtcomm.RtcommEndpoint.html#event:ringing">ringing</a></li><li><a href="module-rtcomm.RtcommEndpoint.html#event:trying">trying</a></li></ul>
</nav>

<br clear="both">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.3.0-dev</a> on Thu Aug 28 2014 13:20:04 GMT-0600 (MDT)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>